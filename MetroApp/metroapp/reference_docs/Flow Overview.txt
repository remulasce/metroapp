
Basic flow:
LA Metro Companion
 - Fintan O'Grady 3/28/15

Service Request || ServiceRequestHandler || Platform Specific Code

Lifecycle <---     list<ServiceRequest>     On User input
- Start       \                             \-> new ServiceRequest()
- Pause        \-- setServiceRequests(<>) <--/
- Cancel
                                            Periodically (500ms)
 getTrips() <----  GetSortedTripList() <------/
 ret List<Trip> -->  ret List<Trip>    -------> Make UI, display.                      



 Types overview:
 ServiceRequest: 
  - Given user input, makes Trips to show back to them
  - Each type of user input should have its own subclassed ServiceRequest
  - - eg. StopServiceRequest displays trips to 1+ Stop
  - Each subclass has its own internal setup to do what it needs.

Trip:
  - Has data the user requested
  - Each becomes one listitem in the main UI
  - Multiple Trips per ServiceRequest OK
  - Last stage of platform-independent code
  - Platform-specific code converts Trip into native UI to display

ServiceRequestHandler
  - It's a glorified list of ServiceRequests
  - It just does some lifecycle management, Trip ordering on top.
  - SetSRequests, GetTripList are major interface between java_core and
       platform specific components.




How it's actually used:

Plat-specific input code needs to make the proper subclass of ServiceRequest to add

We use StopServiceRequests to wrap 1+ stops to track

StopServiceRequest has a whole big hierarchy:
 - Collection<Stop> stops
 - Collection<Prediction> predictions

Stops are backed by StopIDs internally. Each proper name, eg. Vermont / Exposition, 
  may have multiple stopIDs. Vermont / Exposition has stops on both sides of the street,
  and each has a separate stopID. We want to track both sides at the same time, so we add both.

For each Stop we want to get Nextrip arrivals to it.
PredictionManager will get us updates to Predictions.
So we make a StopRouteDestinationPrediction for each stop:

	for (Stop s : stops) {
	    StopRouteDestinationPrediction stopRouteDestinationPrediction = new StopRouteDestinationPrediction(s, null);
	    predictions.add(stopRouteDestinationPrediction);
	}

StopRouteDestinationPrediction extends Prediction
 - Stop stop
 
 - Collection<StopRouteDestinationArrival> arrivals
 - handleResponse(String raw)

SRDP is a subclass of Prediction. The type of Prediction determines how the nextrip arrivals
  are parsed.
SRDP separates the raw arrival xml into separate StopRouteDestinationArrivals

Each different combination of destination + route gets its own StopRouteDestinationArrival.
This is done in handleResponse().

StopRouteDestinationArrival:
  - Stop stop
  - Route route
  - Destination destination

  - Collection<Arrival> arrivals
  - Trip trip
  - void updateArrivals(Arrivals arrivals)

Each SRDA is assigned one Route + Destination. It then looks through the big list of Arrivals from SRDP and adds arrivals that match its R + D to its list.

Each network update in updateArrivals, each SRDA updates its existing arrivals' ETA, creates
  new arrivals, or ignores arrivals that don't correspond to its Destination and Route.

Each SRDA makes one Trip to show. This Trip is specifically a MultiArrivalTrip to display
  all arrivals to its route + destination.


So the total hierarchy of StopServiceRequest:

StopServiceRequest:
 - Collection<Stop> stops
 - Collection<StopRouteDestinationPrediction> predictions
	|
    StopRouteDestinationPrediction:
    -- Stop stop
    -- Collection<StopRouteDestinationArrival> arrivals
    	|
    	StopRouteDestinationArrival:
        --- Destination
        --- Route
        --- Collection<Arrival> arrivals
        	|
        	Arrival:
        	---- Route
        	---- Destination
        	---- Stop
        	---- Vehicle
        	---- Arrival Time

The ServiceRequest gets its total trips from each StopRouteDestinationArrival.
So it walks
foreach(..Prediction : predictions) {
	foreach (..Arrival : arrivals) {
		ret.add(arrival.getTrip());
	}
}
It makes one trip per StopRouteDestinationArrival, which shows multiple arrival times.


Internally the Predictions get updates by registering with the PredictionManager singleton.